在 JavaScript 中，我们对数据进行分组和传递的基本方式是通过对象。在 TypeScript 中，我们通过对象类型来表示这

- 匿名的

  ```ts
  function greet(person: { name: string; age: number }) {
    return "Hello " + person.name;
  }
  ```

- 通过接口定义

  ```ts
  interface Person {
    name: string;
    age: number;
  }
   
  function greet(person: Person) {
    return "Hello " + person.name;
  }
  ```

- 类型别名

  ```ts
  type Person = {
    name: string;
    age: number;
  };
   
  function greet(person: Person) {
    return "Hello " + person.name;
  }
  ```


## 属性修饰符

### 可选属性`?`

通过字名称末尾添加`?`来将属性标记为可选的

```ts
interface PaintOptions {
  shape: Shape;
  xPos?: number;
  yPos?: number;
}
 
function paintShape(opts: PaintOptions) {
  // ...
}
 
const shape = getShape();
paintShape({ shape });
paintShape({ shape, xPos: 100 });
paintShape({ shape, yPos: 100 });
paintShape({ shape, xPos: 100, yPos: 100 });
```

#### 解构设置默认值

```ts
function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {
  console.log("x coordinate at", xPos);
                                  
(parameter) xPos: number
  console.log("y coordinate at", yPos);
                                  
(parameter) yPos: number
  // ...
}
```



**请注意，目前无法在解构模式中放置类型注释。这是因为下面的语法在 JavaScript 中已经意味着不同的东西。**

```ts
function draw({ shape: Shape, xPos: number = 100 /*...*/ }) {
  render(shape); // Cannot find name 'shape'. Did you mean 'Shape'?

  render(xPos); //Cannot find name 'xPos'.

}
```

**在对象解构模式中， `shape: Shape` 表示“获取属性 `shape` 并将其在本地重新定义为名为 `Shape` .同样， `xPos: number` 创建一个名为的 `number` 变量，其值基于参数的 `xPos`**

### 只读属性 `readonly`

```ts
interface SomeType {
  readonly prop: string;
}
 
function doSomething(obj: SomeType) {
  //  你可以读取 `obj.prop`
  console.log(`prop has the value '${obj.prop}'.`);
 
  // 但是你不能修改.
   obj.prop = "hello"; // err: 不能赋值给'prop'，因为它是一个只读属性。

}
```

使用 `readonly` 修饰符并不一定意味着值是完全不可变的 - 换句话说，只是意味着属性本身无法重写

```ts
interface Home {
  readonly resident: { name: string; age: number };
}
 
function visitForBirthday(home: Home) {
  // 我们可以从home.resident读取和更新属性.
  console.log(`Happy birthday ${home.resident.name}!`);
  home.resident.age++;
}
 
function evict(home: Home) {
  home.resident = { //不能分配给'resident'，因为它是一个只读属性
    name: "Victor the Evictor",
    age: 42,
  };
}
```

TypeScript 不会考虑这两种类型的属性是否兼容 `readonly` ，因此 `readonly` 属性也可以通过别名进行更改

```ts
interface Person {
  name: string;
  age: number;
}
 
interface ReadonlyPerson {
  readonly name: string;
  readonly age: number;
}
 
let writablePerson: Person = {
  name: "Person McPersonface",
  age: 42,
};
 
// works
let readonlyPerson: ReadonlyPerson = writablePerson;
 
console.log(readonlyPerson.age); // prints '42'
writablePerson.age++;
console.log(readonlyPerson.age); // prints '43'
```



### 索引签名

```ts
interface StringArray {
  [index: number]: string;
}
 
const myArray: StringArray = getStringArray();
const secondItem = myArray[1]; //const secondItem: string
```

索引签名只支持`string`、`number`、`symbol`  模板字符串 ，和这些类型组成的联合类型

